// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentrequest.proto

#ifndef PROTOBUF_paymentrequest_2eproto__INCLUDED
#define PROTOBUF_paymentrequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace payments {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_paymentrequest_2eproto();
void protobuf_AssignDesc_paymentrequest_2eproto();
void protobuf_ShutdownFile_paymentrequest_2eproto();

class Output;
class PaymentDetails;
class PaymentRequest;
class X509Certificates;
class Payment;
class PaymentACK;

// ===================================================================

class Output : public ::google::protobuf::Message {
 public:
  Output();
  virtual ~Output();
  
  Output(const Output& from);
  
  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();
  
  void Swap(Output* other);
  
  // implements Message ----------------------------------------------
  
  Output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 amount = 1 [default = 0];
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required bytes script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  
  // @@protoc_insertion_point(class_scope:payments.Output)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script();
  inline void clear_has_script();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 amount_;
  ::std::string* script_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_paymentrequest_2eproto();
  friend void protobuf_AssignDesc_paymentrequest_2eproto();
  friend void protobuf_ShutdownFile_paymentrequest_2eproto();
  
  void InitAsDefaultInstance();
  static Output* default_instance_;
};
// -------------------------------------------------------------------

class PaymentDetails : public ::google::protobuf::Message {
 public:
  PaymentDetails();
  virtual ~PaymentDetails();
  
  PaymentDetails(const PaymentDetails& from);
  
  inline PaymentDetails& operator=(const PaymentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentDetails& default_instance();
  
  void Swap(PaymentDetails* other);
  
  // implements Message ----------------------------------------------
  
  PaymentDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaymentDetails& from);
  void MergeFrom(const PaymentDetails& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string network = 1 [default = "main"];
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 1;
  inline const ::std::string& network() const;
  inline void set_network(const ::std::string& value);
  inline void set_network(const char* value);
  inline void set_network(const char* value, size_t size);
  inline ::std::string* mutable_network();
  inline ::std::string* release_network();
  
  // repeated .payments.Output outputs = 2;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  inline const ::payments::Output& outputs(int index) const;
  inline ::payments::Output* mutable_outputs(int index);
  inline ::payments::Output* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::payments::Output >*
      mutable_outputs();
  
  // required uint64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);
  
  // optional uint64 expires = 4;
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 4;
  inline ::google::protobuf::uint64 expires() const;
  inline void set_expires(::google::protobuf::uint64 value);
  
  // optional string memo = 5;
  inline bool has_memo() const;
  inline void clear_memo();
  static const int kMemoFieldNumber = 5;
  inline const ::std::string& memo() const;
  inline void set_memo(const ::std::string& value);
  inline void set_memo(const char* value);
  inline void set_memo(const char* value, size_t size);
  inline ::std::string* mutable_memo();
  inline ::std::string* release_memo();
  
  // optional string payment_url = 6;
  inline bool has_payment_url() const;
  inline void clear_payment_url();
  static const int kPaymentUrlFieldNumber = 6;
  inline const ::std::string& payment_url() const;
  inline void set_payment_url(const ::std::string& value);
  inline void set_payment_url(const char* value);
  inline void set_payment_url(const char* value, size_t size);
  inline ::std::string* mutable_payment_url();
  inline ::std::string* release_payment_url();
  
  // optional bytes merchant_data = 7;
  inline bool has_merchant_data() const;
  inline void clear_merchant_data();
  static const int kMerchantDataFieldNumber = 7;
  inline const ::std::string& merchant_data() const;
  inline void set_merchant_data(const ::std::string& value);
  inline void set_merchant_data(const char* value);
  inline void set_merchant_data(const void* value, size_t size);
  inline ::std::string* mutable_merchant_data();
  inline ::std::string* release_merchant_data();
  
  // @@protoc_insertion_point(class_scope:payments.PaymentDetails)
 private:
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_memo();
  inline void clear_has_memo();
  inline void set_has_payment_url();
  inline void clear_has_payment_url();
  inline void set_has_merchant_data();
  inline void clear_has_merchant_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* network_;
  static const ::std::string _default_network_;
  ::google::protobuf::RepeatedPtrField< ::payments::Output > outputs_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint64 expires_;
  ::std::string* memo_;
  ::std::string* payment_url_;
  ::std::string* merchant_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_paymentrequest_2eproto();
  friend void protobuf_AssignDesc_paymentrequest_2eproto();
  friend void protobuf_ShutdownFile_paymentrequest_2eproto();
  
  void InitAsDefaultInstance();
  static PaymentDetails* default_instance_;
};
// -------------------------------------------------------------------

class PaymentRequest : public ::google::protobuf::Message {
 public:
  PaymentRequest();
  virtual ~PaymentRequest();
  
  PaymentRequest(const PaymentRequest& from);
  
  inline PaymentRequest& operator=(const PaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentRequest& default_instance();
  
  void Swap(PaymentRequest* other);
  
  // implements Message ----------------------------------------------
  
  PaymentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaymentRequest& from);
  void MergeFrom(const PaymentRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 payment_details_version = 1 [default = 1];
  inline bool has_payment_details_version() const;
  inline void clear_payment_details_version();
  static const int kPaymentDetailsVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 payment_details_version() const;
  inline void set_payment_details_version(::google::protobuf::uint32 value);
  
  // optional string pki_type = 2 [default = "none"];
  inline bool has_pki_type() const;
  inline void clear_pki_type();
  static const int kPkiTypeFieldNumber = 2;
  inline const ::std::string& pki_type() const;
  inline void set_pki_type(const ::std::string& value);
  inline void set_pki_type(const char* value);
  inline void set_pki_type(const char* value, size_t size);
  inline ::std::string* mutable_pki_type();
  inline ::std::string* release_pki_type();
  
  // optional bytes pki_data = 3;
  inline bool has_pki_data() const;
  inline void clear_pki_data();
  static const int kPkiDataFieldNumber = 3;
  inline const ::std::string& pki_data() const;
  inline void set_pki_data(const ::std::string& value);
  inline void set_pki_data(const char* value);
  inline void set_pki_data(const void* value, size_t size);
  inline ::std::string* mutable_pki_data();
  inline ::std::string* release_pki_data();
  
  // required bytes serialized_payment_details = 4;
  inline bool has_serialized_payment_details() const;
  inline void clear_serialized_payment_details();
  static const int kSerializedPaymentDetailsFieldNumber = 4;
  inline const ::std::string& serialized_payment_details() const;
  inline void set_serialized_payment_details(const ::std::string& value);
  inline void set_serialized_payment_details(const char* value);
  inline void set_serialized_payment_details(const void* value, size_t size);
  inline ::std::string* mutable_serialized_payment_details();
  inline ::std::string* release_serialized_payment_details();
  
  // optional bytes signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  
  // @@protoc_insertion_point(class_scope:payments.PaymentRequest)
 private:
  inline void set_has_payment_details_version();
  inline void clear_has_payment_details_version();
  inline void set_has_pki_type();
  inline void clear_has_pki_type();
  inline void set_has_pki_data();
  inline void clear_has_pki_data();
  inline void set_has_serialized_payment_details();
  inline void clear_has_serialized_payment_details();
  inline void set_has_signature();
  inline void clear_has_signature();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pki_type_;
  static const ::std::string _default_pki_type_;
  ::std::string* pki_data_;
  ::std::string* serialized_payment_details_;
  ::std::string* signature_;
  ::google::protobuf::uint32 payment_details_version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_paymentrequest_2eproto();
  friend void protobuf_AssignDesc_paymentrequest_2eproto();
  friend void protobuf_ShutdownFile_paymentrequest_2eproto();
  
  void InitAsDefaultInstance();
  static PaymentRequest* default_instance_;
};
// -------------------------------------------------------------------

class X509Certificates : public ::google::protobuf::Message {
 public:
  X509Certificates();
  virtual ~X509Certificates();
  
  X509Certificates(const X509Certificates& from);
  
  inline X509Certificates& operator=(const X509Certificates& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X509Certificates& default_instance();
  
  void Swap(X509Certificates* other);
  
  // implements Message ----------------------------------------------
  
  X509Certificates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X509Certificates& from);
  void MergeFrom(const X509Certificates& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes certificate = 1;
  inline int certificate_size() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 1;
  inline const ::std::string& certificate(int index) const;
  inline ::std::string* mutable_certificate(int index);
  inline void set_certificate(int index, const ::std::string& value);
  inline void set_certificate(int index, const char* value);
  inline void set_certificate(int index, const void* value, size_t size);
  inline ::std::string* add_certificate();
  inline void add_certificate(const ::std::string& value);
  inline void add_certificate(const char* value);
  inline void add_certificate(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& certificate() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_certificate();
  
  // @@protoc_insertion_point(class_scope:payments.X509Certificates)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> certificate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_paymentrequest_2eproto();
  friend void protobuf_AssignDesc_paymentrequest_2eproto();
  friend void protobuf_ShutdownFile_paymentrequest_2eproto();
  
  void InitAsDefaultInstance();
  static X509Certificates* default_instance_;
};
// -------------------------------------------------------------------

class Payment : public ::google::protobuf::Message {
 public:
  Payment();
  virtual ~Payment();
  
  Payment(const Payment& from);
  
  inline Payment& operator=(const Payment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Payment& default_instance();
  
  void Swap(Payment* other);
  
  // implements Message ----------------------------------------------
  
  Payment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Payment& from);
  void MergeFrom(const Payment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes merchant_data = 1;
  inline bool has_merchant_data() const;
  inline void clear_merchant_data();
  static const int kMerchantDataFieldNumber = 1;
  inline const ::std::string& merchant_data() const;
  inline void set_merchant_data(const ::std::string& value);
  inline void set_merchant_data(const char* value);
  inline void set_merchant_data(const void* value, size_t size);
  inline ::std::string* mutable_merchant_data();
  inline ::std::string* release_merchant_data();
  
  // repeated bytes transactions = 2;
  inline int transactions_size() const;
  inline void clear_transactions();
  static const int kTransactionsFieldNumber = 2;
  inline const ::std::string& transactions(int index) const;
  inline ::std::string* mutable_transactions(int index);
  inline void set_transactions(int index, const ::std::string& value);
  inline void set_transactions(int index, const char* value);
  inline void set_transactions(int index, const void* value, size_t size);
  inline ::std::string* add_transactions();
  inline void add_transactions(const ::std::string& value);
  inline void add_transactions(const char* value);
  inline void add_transactions(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_transactions();
  
  // repeated .payments.Output refund_to = 3;
  inline int refund_to_size() const;
  inline void clear_refund_to();
  static const int kRefundToFieldNumber = 3;
  inline const ::payments::Output& refund_to(int index) const;
  inline ::payments::Output* mutable_refund_to(int index);
  inline ::payments::Output* add_refund_to();
  inline const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
      refund_to() const;
  inline ::google::protobuf::RepeatedPtrField< ::payments::Output >*
      mutable_refund_to();
  
  // optional string memo = 4;
  inline bool has_memo() const;
  inline void clear_memo();
  static const int kMemoFieldNumber = 4;
  inline const ::std::string& memo() const;
  inline void set_memo(const ::std::string& value);
  inline void set_memo(const char* value);
  inline void set_memo(const char* value, size_t size);
  inline ::std::string* mutable_memo();
  inline ::std::string* release_memo();
  
  // @@protoc_insertion_point(class_scope:payments.Payment)
 private:
  inline void set_has_merchant_data();
  inline void clear_has_merchant_data();
  inline void set_has_memo();
  inline void clear_has_memo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* merchant_data_;
  ::google::protobuf::RepeatedPtrField< ::std::string> transactions_;
  ::google::protobuf::RepeatedPtrField< ::payments::Output > refund_to_;
  ::std::string* memo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_paymentrequest_2eproto();
  friend void protobuf_AssignDesc_paymentrequest_2eproto();
  friend void protobuf_ShutdownFile_paymentrequest_2eproto();
  
  void InitAsDefaultInstance();
  static Payment* default_instance_;
};
// -------------------------------------------------------------------

class PaymentACK : public ::google::protobuf::Message {
 public:
  PaymentACK();
  virtual ~PaymentACK();
  
  PaymentACK(const PaymentACK& from);
  
  inline PaymentACK& operator=(const PaymentACK& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PaymentACK& default_instance();
  
  void Swap(PaymentACK* other);
  
  // implements Message ----------------------------------------------
  
  PaymentACK* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaymentACK& from);
  void MergeFrom(const PaymentACK& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .payments.Payment payment = 1;
  inline bool has_payment() const;
  inline void clear_payment();
  static const int kPaymentFieldNumber = 1;
  inline const ::payments::Payment& payment() const;
  inline ::payments::Payment* mutable_payment();
  inline ::payments::Payment* release_payment();
  
  // optional string memo = 2;
  inline bool has_memo() const;
  inline void clear_memo();
  static const int kMemoFieldNumber = 2;
  inline const ::std::string& memo() const;
  inline void set_memo(const ::std::string& value);
  inline void set_memo(const char* value);
  inline void set_memo(const char* value, size_t size);
  inline ::std::string* mutable_memo();
  inline ::std::string* release_memo();
  
  // @@protoc_insertion_point(class_scope:payments.PaymentACK)
 private:
  inline void set_has_payment();
  inline void clear_has_payment();
  inline void set_has_memo();
  inline void clear_has_memo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::payments::Payment* payment_;
  ::std::string* memo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_paymentrequest_2eproto();
  friend void protobuf_AssignDesc_paymentrequest_2eproto();
  friend void protobuf_ShutdownFile_paymentrequest_2eproto();
  
  void InitAsDefaultInstance();
  static PaymentACK* default_instance_;
};
// ===================================================================


// ===================================================================

// Output

// optional uint64 amount = 1 [default = 0];
inline bool Output::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Output::amount() const {
  return amount_;
}
inline void Output::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required bytes script = 2;
inline bool Output::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_script() {
  if (script_ != &::google::protobuf::internal::kEmptyString) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& Output::script() const {
  return *script_;
}
inline void Output::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void Output::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void Output::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Output::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    script_ = new ::std::string;
  }
  return script_;
}
inline ::std::string* Output::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PaymentDetails

// optional string network = 1 [default = "main"];
inline bool PaymentDetails::has_network() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentDetails::set_has_network() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentDetails::clear_has_network() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentDetails::clear_network() {
  if (network_ != &_default_network_) {
    network_->assign(_default_network_);
  }
  clear_has_network();
}
inline const ::std::string& PaymentDetails::network() const {
  return *network_;
}
inline void PaymentDetails::set_network(const ::std::string& value) {
  set_has_network();
  if (network_ == &_default_network_) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void PaymentDetails::set_network(const char* value) {
  set_has_network();
  if (network_ == &_default_network_) {
    network_ = new ::std::string;
  }
  network_->assign(value);
}
inline void PaymentDetails::set_network(const char* value, size_t size) {
  set_has_network();
  if (network_ == &_default_network_) {
    network_ = new ::std::string;
  }
  network_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentDetails::mutable_network() {
  set_has_network();
  if (network_ == &_default_network_) {
    network_ = new ::std::string(_default_network_);
  }
  return network_;
}
inline ::std::string* PaymentDetails::release_network() {
  clear_has_network();
  if (network_ == &_default_network_) {
    return NULL;
  } else {
    ::std::string* temp = network_;
    network_ = const_cast< ::std::string*>(&_default_network_);
    return temp;
  }
}

// repeated .payments.Output outputs = 2;
inline int PaymentDetails::outputs_size() const {
  return outputs_.size();
}
inline void PaymentDetails::clear_outputs() {
  outputs_.Clear();
}
inline const ::payments::Output& PaymentDetails::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::payments::Output* PaymentDetails::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::payments::Output* PaymentDetails::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
PaymentDetails::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::payments::Output >*
PaymentDetails::mutable_outputs() {
  return &outputs_;
}

// required uint64 time = 3;
inline bool PaymentDetails::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaymentDetails::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaymentDetails::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaymentDetails::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 PaymentDetails::time() const {
  return time_;
}
inline void PaymentDetails::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// optional uint64 expires = 4;
inline bool PaymentDetails::has_expires() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaymentDetails::set_has_expires() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaymentDetails::clear_has_expires() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaymentDetails::clear_expires() {
  expires_ = GOOGLE_ULONGLONG(0);
  clear_has_expires();
}
inline ::google::protobuf::uint64 PaymentDetails::expires() const {
  return expires_;
}
inline void PaymentDetails::set_expires(::google::protobuf::uint64 value) {
  set_has_expires();
  expires_ = value;
}

// optional string memo = 5;
inline bool PaymentDetails::has_memo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaymentDetails::set_has_memo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaymentDetails::clear_has_memo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaymentDetails::clear_memo() {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    memo_->clear();
  }
  clear_has_memo();
}
inline const ::std::string& PaymentDetails::memo() const {
  return *memo_;
}
inline void PaymentDetails::set_memo(const ::std::string& value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void PaymentDetails::set_memo(const char* value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void PaymentDetails::set_memo(const char* value, size_t size) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentDetails::mutable_memo() {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  return memo_;
}
inline ::std::string* PaymentDetails::release_memo() {
  clear_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memo_;
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string payment_url = 6;
inline bool PaymentDetails::has_payment_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PaymentDetails::set_has_payment_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PaymentDetails::clear_has_payment_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PaymentDetails::clear_payment_url() {
  if (payment_url_ != &::google::protobuf::internal::kEmptyString) {
    payment_url_->clear();
  }
  clear_has_payment_url();
}
inline const ::std::string& PaymentDetails::payment_url() const {
  return *payment_url_;
}
inline void PaymentDetails::set_payment_url(const ::std::string& value) {
  set_has_payment_url();
  if (payment_url_ == &::google::protobuf::internal::kEmptyString) {
    payment_url_ = new ::std::string;
  }
  payment_url_->assign(value);
}
inline void PaymentDetails::set_payment_url(const char* value) {
  set_has_payment_url();
  if (payment_url_ == &::google::protobuf::internal::kEmptyString) {
    payment_url_ = new ::std::string;
  }
  payment_url_->assign(value);
}
inline void PaymentDetails::set_payment_url(const char* value, size_t size) {
  set_has_payment_url();
  if (payment_url_ == &::google::protobuf::internal::kEmptyString) {
    payment_url_ = new ::std::string;
  }
  payment_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentDetails::mutable_payment_url() {
  set_has_payment_url();
  if (payment_url_ == &::google::protobuf::internal::kEmptyString) {
    payment_url_ = new ::std::string;
  }
  return payment_url_;
}
inline ::std::string* PaymentDetails::release_payment_url() {
  clear_has_payment_url();
  if (payment_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payment_url_;
    payment_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes merchant_data = 7;
inline bool PaymentDetails::has_merchant_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PaymentDetails::set_has_merchant_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PaymentDetails::clear_has_merchant_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PaymentDetails::clear_merchant_data() {
  if (merchant_data_ != &::google::protobuf::internal::kEmptyString) {
    merchant_data_->clear();
  }
  clear_has_merchant_data();
}
inline const ::std::string& PaymentDetails::merchant_data() const {
  return *merchant_data_;
}
inline void PaymentDetails::set_merchant_data(const ::std::string& value) {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  merchant_data_->assign(value);
}
inline void PaymentDetails::set_merchant_data(const char* value) {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  merchant_data_->assign(value);
}
inline void PaymentDetails::set_merchant_data(const void* value, size_t size) {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  merchant_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentDetails::mutable_merchant_data() {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  return merchant_data_;
}
inline ::std::string* PaymentDetails::release_merchant_data() {
  clear_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merchant_data_;
    merchant_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PaymentRequest

// optional uint32 payment_details_version = 1 [default = 1];
inline bool PaymentRequest::has_payment_details_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentRequest::set_has_payment_details_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentRequest::clear_has_payment_details_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentRequest::clear_payment_details_version() {
  payment_details_version_ = 1u;
  clear_has_payment_details_version();
}
inline ::google::protobuf::uint32 PaymentRequest::payment_details_version() const {
  return payment_details_version_;
}
inline void PaymentRequest::set_payment_details_version(::google::protobuf::uint32 value) {
  set_has_payment_details_version();
  payment_details_version_ = value;
}

// optional string pki_type = 2 [default = "none"];
inline bool PaymentRequest::has_pki_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaymentRequest::set_has_pki_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaymentRequest::clear_has_pki_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaymentRequest::clear_pki_type() {
  if (pki_type_ != &_default_pki_type_) {
    pki_type_->assign(_default_pki_type_);
  }
  clear_has_pki_type();
}
inline const ::std::string& PaymentRequest::pki_type() const {
  return *pki_type_;
}
inline void PaymentRequest::set_pki_type(const ::std::string& value) {
  set_has_pki_type();
  if (pki_type_ == &_default_pki_type_) {
    pki_type_ = new ::std::string;
  }
  pki_type_->assign(value);
}
inline void PaymentRequest::set_pki_type(const char* value) {
  set_has_pki_type();
  if (pki_type_ == &_default_pki_type_) {
    pki_type_ = new ::std::string;
  }
  pki_type_->assign(value);
}
inline void PaymentRequest::set_pki_type(const char* value, size_t size) {
  set_has_pki_type();
  if (pki_type_ == &_default_pki_type_) {
    pki_type_ = new ::std::string;
  }
  pki_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentRequest::mutable_pki_type() {
  set_has_pki_type();
  if (pki_type_ == &_default_pki_type_) {
    pki_type_ = new ::std::string(_default_pki_type_);
  }
  return pki_type_;
}
inline ::std::string* PaymentRequest::release_pki_type() {
  clear_has_pki_type();
  if (pki_type_ == &_default_pki_type_) {
    return NULL;
  } else {
    ::std::string* temp = pki_type_;
    pki_type_ = const_cast< ::std::string*>(&_default_pki_type_);
    return temp;
  }
}

// optional bytes pki_data = 3;
inline bool PaymentRequest::has_pki_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaymentRequest::set_has_pki_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaymentRequest::clear_has_pki_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaymentRequest::clear_pki_data() {
  if (pki_data_ != &::google::protobuf::internal::kEmptyString) {
    pki_data_->clear();
  }
  clear_has_pki_data();
}
inline const ::std::string& PaymentRequest::pki_data() const {
  return *pki_data_;
}
inline void PaymentRequest::set_pki_data(const ::std::string& value) {
  set_has_pki_data();
  if (pki_data_ == &::google::protobuf::internal::kEmptyString) {
    pki_data_ = new ::std::string;
  }
  pki_data_->assign(value);
}
inline void PaymentRequest::set_pki_data(const char* value) {
  set_has_pki_data();
  if (pki_data_ == &::google::protobuf::internal::kEmptyString) {
    pki_data_ = new ::std::string;
  }
  pki_data_->assign(value);
}
inline void PaymentRequest::set_pki_data(const void* value, size_t size) {
  set_has_pki_data();
  if (pki_data_ == &::google::protobuf::internal::kEmptyString) {
    pki_data_ = new ::std::string;
  }
  pki_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentRequest::mutable_pki_data() {
  set_has_pki_data();
  if (pki_data_ == &::google::protobuf::internal::kEmptyString) {
    pki_data_ = new ::std::string;
  }
  return pki_data_;
}
inline ::std::string* PaymentRequest::release_pki_data() {
  clear_has_pki_data();
  if (pki_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pki_data_;
    pki_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes serialized_payment_details = 4;
inline bool PaymentRequest::has_serialized_payment_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaymentRequest::set_has_serialized_payment_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaymentRequest::clear_has_serialized_payment_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaymentRequest::clear_serialized_payment_details() {
  if (serialized_payment_details_ != &::google::protobuf::internal::kEmptyString) {
    serialized_payment_details_->clear();
  }
  clear_has_serialized_payment_details();
}
inline const ::std::string& PaymentRequest::serialized_payment_details() const {
  return *serialized_payment_details_;
}
inline void PaymentRequest::set_serialized_payment_details(const ::std::string& value) {
  set_has_serialized_payment_details();
  if (serialized_payment_details_ == &::google::protobuf::internal::kEmptyString) {
    serialized_payment_details_ = new ::std::string;
  }
  serialized_payment_details_->assign(value);
}
inline void PaymentRequest::set_serialized_payment_details(const char* value) {
  set_has_serialized_payment_details();
  if (serialized_payment_details_ == &::google::protobuf::internal::kEmptyString) {
    serialized_payment_details_ = new ::std::string;
  }
  serialized_payment_details_->assign(value);
}
inline void PaymentRequest::set_serialized_payment_details(const void* value, size_t size) {
  set_has_serialized_payment_details();
  if (serialized_payment_details_ == &::google::protobuf::internal::kEmptyString) {
    serialized_payment_details_ = new ::std::string;
  }
  serialized_payment_details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentRequest::mutable_serialized_payment_details() {
  set_has_serialized_payment_details();
  if (serialized_payment_details_ == &::google::protobuf::internal::kEmptyString) {
    serialized_payment_details_ = new ::std::string;
  }
  return serialized_payment_details_;
}
inline ::std::string* PaymentRequest::release_serialized_payment_details() {
  clear_has_serialized_payment_details();
  if (serialized_payment_details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_payment_details_;
    serialized_payment_details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes signature = 5;
inline bool PaymentRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaymentRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaymentRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaymentRequest::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& PaymentRequest::signature() const {
  return *signature_;
}
inline void PaymentRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void PaymentRequest::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void PaymentRequest::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* PaymentRequest::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// X509Certificates

// repeated bytes certificate = 1;
inline int X509Certificates::certificate_size() const {
  return certificate_.size();
}
inline void X509Certificates::clear_certificate() {
  certificate_.Clear();
}
inline const ::std::string& X509Certificates::certificate(int index) const {
  return certificate_.Get(index);
}
inline ::std::string* X509Certificates::mutable_certificate(int index) {
  return certificate_.Mutable(index);
}
inline void X509Certificates::set_certificate(int index, const ::std::string& value) {
  certificate_.Mutable(index)->assign(value);
}
inline void X509Certificates::set_certificate(int index, const char* value) {
  certificate_.Mutable(index)->assign(value);
}
inline void X509Certificates::set_certificate(int index, const void* value, size_t size) {
  certificate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X509Certificates::add_certificate() {
  return certificate_.Add();
}
inline void X509Certificates::add_certificate(const ::std::string& value) {
  certificate_.Add()->assign(value);
}
inline void X509Certificates::add_certificate(const char* value) {
  certificate_.Add()->assign(value);
}
inline void X509Certificates::add_certificate(const void* value, size_t size) {
  certificate_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
X509Certificates::certificate() const {
  return certificate_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
X509Certificates::mutable_certificate() {
  return &certificate_;
}

// -------------------------------------------------------------------

// Payment

// optional bytes merchant_data = 1;
inline bool Payment::has_merchant_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Payment::set_has_merchant_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Payment::clear_has_merchant_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Payment::clear_merchant_data() {
  if (merchant_data_ != &::google::protobuf::internal::kEmptyString) {
    merchant_data_->clear();
  }
  clear_has_merchant_data();
}
inline const ::std::string& Payment::merchant_data() const {
  return *merchant_data_;
}
inline void Payment::set_merchant_data(const ::std::string& value) {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  merchant_data_->assign(value);
}
inline void Payment::set_merchant_data(const char* value) {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  merchant_data_->assign(value);
}
inline void Payment::set_merchant_data(const void* value, size_t size) {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  merchant_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Payment::mutable_merchant_data() {
  set_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    merchant_data_ = new ::std::string;
  }
  return merchant_data_;
}
inline ::std::string* Payment::release_merchant_data() {
  clear_has_merchant_data();
  if (merchant_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = merchant_data_;
    merchant_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes transactions = 2;
inline int Payment::transactions_size() const {
  return transactions_.size();
}
inline void Payment::clear_transactions() {
  transactions_.Clear();
}
inline const ::std::string& Payment::transactions(int index) const {
  return transactions_.Get(index);
}
inline ::std::string* Payment::mutable_transactions(int index) {
  return transactions_.Mutable(index);
}
inline void Payment::set_transactions(int index, const ::std::string& value) {
  transactions_.Mutable(index)->assign(value);
}
inline void Payment::set_transactions(int index, const char* value) {
  transactions_.Mutable(index)->assign(value);
}
inline void Payment::set_transactions(int index, const void* value, size_t size) {
  transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Payment::add_transactions() {
  return transactions_.Add();
}
inline void Payment::add_transactions(const ::std::string& value) {
  transactions_.Add()->assign(value);
}
inline void Payment::add_transactions(const char* value) {
  transactions_.Add()->assign(value);
}
inline void Payment::add_transactions(const void* value, size_t size) {
  transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Payment::transactions() const {
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Payment::mutable_transactions() {
  return &transactions_;
}

// repeated .payments.Output refund_to = 3;
inline int Payment::refund_to_size() const {
  return refund_to_.size();
}
inline void Payment::clear_refund_to() {
  refund_to_.Clear();
}
inline const ::payments::Output& Payment::refund_to(int index) const {
  return refund_to_.Get(index);
}
inline ::payments::Output* Payment::mutable_refund_to(int index) {
  return refund_to_.Mutable(index);
}
inline ::payments::Output* Payment::add_refund_to() {
  return refund_to_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::payments::Output >&
Payment::refund_to() const {
  return refund_to_;
}
inline ::google::protobuf::RepeatedPtrField< ::payments::Output >*
Payment::mutable_refund_to() {
  return &refund_to_;
}

// optional string memo = 4;
inline bool Payment::has_memo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Payment::set_has_memo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Payment::clear_has_memo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Payment::clear_memo() {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    memo_->clear();
  }
  clear_has_memo();
}
inline const ::std::string& Payment::memo() const {
  return *memo_;
}
inline void Payment::set_memo(const ::std::string& value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void Payment::set_memo(const char* value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void Payment::set_memo(const char* value, size_t size) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Payment::mutable_memo() {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  return memo_;
}
inline ::std::string* Payment::release_memo() {
  clear_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memo_;
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PaymentACK

// required .payments.Payment payment = 1;
inline bool PaymentACK::has_payment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaymentACK::set_has_payment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaymentACK::clear_has_payment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaymentACK::clear_payment() {
  if (payment_ != NULL) payment_->::payments::Payment::Clear();
  clear_has_payment();
}
inline const ::payments::Payment& PaymentACK::payment() const {
  return payment_ != NULL ? *payment_ : *default_instance_->payment_;
}
inline ::payments::Payment* PaymentACK::mutable_payment() {
  set_has_payment();
  if (payment_ == NULL) payment_ = new ::payments::Payment;
  return payment_;
}
inline ::payments::Payment* PaymentACK::release_payment() {
  clear_has_payment();
  ::payments::Payment* temp = payment_;
  payment_ = NULL;
  return temp;
}

// optional string memo = 2;
inline bool PaymentACK::has_memo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaymentACK::set_has_memo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaymentACK::clear_has_memo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaymentACK::clear_memo() {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    memo_->clear();
  }
  clear_has_memo();
}
inline const ::std::string& PaymentACK::memo() const {
  return *memo_;
}
inline void PaymentACK::set_memo(const ::std::string& value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void PaymentACK::set_memo(const char* value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void PaymentACK::set_memo(const char* value, size_t size) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PaymentACK::mutable_memo() {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  return memo_;
}
inline ::std::string* PaymentACK::release_memo() {
  clear_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memo_;
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace payments

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_paymentrequest_2eproto__INCLUDED
